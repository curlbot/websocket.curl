||| Copyright (C) SCSK Corp. All Rights Reserved.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

|||
||| @author
|||

{import MsgDigest-of-len, MsgDigester-for from CURL.CRYPTO.MSG-DIGEST}

||
|| MD5-Digest
||
{define-class package MD5-Digest
  {inherits {MsgDigest-of-len 4}}
  
  {getter public {oid}:String
    {return "1.2.840.113549.2.5"}
  }

  {method public {clone}:MD5-Digest
    {return {MD5-Digest {String self}}}
  }

  {constructor package {default str:StringInterface}
    {construct-super.from-string str}
  }

  {constructor package {from-bytes bytes:ByteVec}
    let buf:StringBuf = {StringBuf}
    {for b in bytes do
        {format out = buf, "%.2x", b}
    }
    {construct-super.from-string buf}
  }
}

||
|| MD5-Digester
||
{define-class package MD5-Digester
  {inherits {MsgDigester-for MD5-Digest}}

  field private constant buf:ByteVec
  field private constant md5:MD5 
  field private _started?:bool
  
  {getter public {started?}:bool
    {return self._started?} 
  }
  
  {constructor package {default
                           char-encoding:CharEncoding = CharEncoding.utf8,
                           buffer-size:int = 64
                       }
    {construct-super char-encoding = char-encoding}
    set self.buf = {ByteVec max-size = buffer-size}
    set self.md5 = {MD5}
  }

  {method public sealed {start}:void
    {self.buf.clear}
    {self.md5.init}
    set self._started? = true
  }

  {method public final {add-byte b:byte}:void
    {self.buf.append b}
    || if buf is full.
    {if self.buf.size == self.buf.max-size then
        {self.add-bytes}
    }
  }

  {method public final {finish}:MD5-Digest
    {if self.buf.size > 0 then
        {self.add-bytes}
    }
    set self._started? = false
    {return {MD5-Digest.from-bytes {self.md5.finalize}}}
  }
  
  {method private {add-bytes}:void
    def bytes = {{FastArray-of int8} max-size = self.buf.size}
    {for v in self.buf do
        {bytes.append v asa int8}
    }
    {self.md5.update bytes}
    {self.buf.clear}
  }
}
  

|| MessageDigest MD5
{define-class package final MD5

  field private state:{FastArray-of int64}      || state (ABCD)
  field private bits:{FastArray-of int64}       || number of bits, modulo 2^64 (lsb first) 
  field private input-buf:{FastArray-of int8}   || input buffer 

  {constructor package {default}
    set self.state = {{FastArray-of int64}.from-size 4, 0}
    set self.bits = {{FastArray-of int64}.from-size 2, 0}
    set self.input-buf = {{FastArray-of int8}.from-size 64, 0}
  }
  
  {method package {to-digest
                      src:String
                  }:String
    def bytes = {{FastArray-of int8} max-size = src.size}
    {for c in src do
        {bytes.append c asa int8}
    }
    {return {hex-encode {self.to-digest-as-bytes bytes}}}
  }
  
  {method package {to-digest-as-bytes
                      src:{FastArray-of int8}
                  }:ByteVec
    || initialize
    {self.init}
    
    || update
    {self.update src}

    || finalize
    {return {self.finalize}}
  }

  
  || - - - private and package- - -

  {method package {init}:void
    || initialize
    set self.state[0] = 0x067452301 
    set self.state[1] = 0x0efcdab89 
    set self.state[2] = 0x098badcfe 
    set self.state[3] = 0x010325476 
    
    set self.bits[0] = 0
    set self.bits[1] = 0
  }
  
  {method package {update
                      buf:{FastArray-of int8}
                  }:void
    || Update bit count
    let len:int = buf.size
    let t:int64 = self.bits[0]
    set self.bits[0] = t + {bit-sll len, 3}
    {if self.bits[0] < t then
        {inc self.bits[1]}
    }
    set self.bits[1] = self.bits[1] + {bit-sra len, 29}
    set t = {bit-and {bit-sra t, 3}, 0x3f}

    def copy-p =
        {proc {des:{FastArray-of int8},
               des-offset:int,
               src:{FastArray-of int8},
               src-offset:int,
               len:int
              }:void
            {for i = 0 below len do
                set des[des-offset + i] = src[src-offset + i]
            }
        }
    
    || Handle any leading odd-sized chunks
    {if t != 0 then
        def p = t
        set t = {bit-and (64 - t), 0x0ffffffff}
        {if len < t then
            {copy-p self.input-buf, t asa int, buf, 0, len}
            {return}
        }
        {copy-p self.input-buf, t asa int, buf, 0, t asa int}
        {self.apply-round}
        set len = (len - t) asa int
    }
    || Process data in 64-byte chunks
    {while len >= 64 do
        {copy-p self.input-buf, 0, buf, t asa int, 64}
        {self.apply-round}
        set t = t + 64
        set len = len - 64
    }
    || Handle any remaining bytes of data.
    {copy-p self.input-buf, 0, buf, t asa int, len}
  }

  {method package {finalize}:ByteVec
    || finalize
    || Compute number of bytes mod 64
    let count:int64 = {bit-and {bit-sra self.bits[0], 3}, 0x3f}

    || Set the first char of padding to 0x80.  This is safe since there is
    || always at least one byte free 
    set self.input-buf[count asa int] = 0x080 asa int8
    let p:int64 = count + 1

    || Bytes of padding needed to make 64 bytes
    set count = 64 - 1 - count

    def set-p =
        {proc {des:{FastArray-of int8},
               des-offset:int,
               dat:int8,
               len:int
              }:void
            {for i = 0 below len do
                set des[des-offset + i] = dat
            }
        }
    || Pad out to 56 mod 64
    {if count < 8 then
        || Two lots of padding:  Pad the first block to 64 bytes 
        {set-p self.input-buf, p asa int, 0, count asa int}
        {self.apply-round}
        || Now fill the next block with 56 bytes 
        {set-p self.input-buf, 0, 0, 56}
     else 
        || Pad block to 56 bytes 
        {set-p self.input-buf, p asa int, 0, (count - 8) asa int}
    }
    
    || Append length in bits and transform 
    set self.input-buf[(14 * 4) + 0] = self.bits[0] asa int8
    set self.input-buf[(14 * 4) + 1] = {bit-sra self.bits[0],  8} asa int8
    set self.input-buf[(14 * 4) + 2] = {bit-sra self.bits[0], 16} asa int8
    set self.input-buf[(14 * 4) + 3] = {bit-sra self.bits[0], 24} asa int8
    set self.input-buf[(15 * 4) + 0] = self.bits[1] asa int8
    set self.input-buf[(15 * 4) + 1] = {bit-sra self.bits[1],  8} asa int8
    set self.input-buf[(15 * 4) + 2] = {bit-sra self.bits[1], 16} asa int8
    set self.input-buf[(15 * 4) + 3] = {bit-sra self.bits[1], 24} asa int8

    {self.apply-round}
    def digest = {ByteVec.from-size 16, 0}
    {for i = 0 below 4 do
        def c = i * 4
        set digest[c + 0] = self.state[i] asa uint8
        set digest[c + 1] = {bit-sra self.state[i],  8} asa uint8
        set digest[c + 2] = {bit-sra self.state[i], 16} asa uint8
        set digest[c + 3] = {bit-sra self.state[i], 24} asa uint8
    }

    {self.init}
    {return digest}
  }
  
  {method private {apply-round}:void
    def to-int-p =
        {proc {src:{FastArray-of int8}, offset-lng:int}:int64
            {return 
                {bit-or
                    {bit-and src[(offset-lng * 4) + 0], 0x0000000ff} asa int64,
                    {bit-and 
                        {bit-sll src[(offset-lng * 4) + 1], 8}, 
                        0x00000ff00
                    } asa int64,
                    {bit-and 
                        {bit-sll src[(offset-lng * 4) + 2], 16}, 
                        0x000ff0000
                    } asa int64,
                    {bit-and 
                        {bit-sll src[(offset-lng * 4) + 3], 24}, 
                        0x0ff000000
                    } asa int64
                }
            }
        }
    def round1-p =
        {proc {x:int64, y:int64, z:int64}:int64
            {return {bit-and {bit-xor z, {bit-and x, {bit-xor y, z}}}, 0x0ffffffff}}
        }
    def round2-p =
        {proc {x:int64, y:int64, z:int64}:int64
            {return {round1-p z, x, y}}
        }
    def round3-p =
        {proc {x:int64, y:int64, z:int64}:int64
            {return {bit-and {bit-xor x, y, z}, 0x0ffffffff}}
        }
    def round4-p =
        {proc {x:int64, y:int64, z:int64}:int64
            {return {bit-and {bit-xor y, {bit-or x, {bit-not z}}}, 0x0ffffffff}}
        }
    
    def step-p =
        {proc {w:int64, f:int64, x:int64, y:int64, z:int64, data:int64, s:int64}:int64
            || HACK int instead of int64 due to bit-xxx procs are not supported.
            let v:int64 = {bit-and (w + f + data), (0x0ffffffff asa uint)}
            set v = {bit-and
                        {bit-or
                            {bit-sll v, s asa int}, {bit-sra v, 32 - s asa int}
                        },
                        (0x0ffffffff asa uint)
                    }
            {return {bit-and (v + x), (0x0ffffffff asa uint)}}
        }
    
    || state ABCD
    let a:int64 = self.state[0]
    let b:int64 = self.state[1]
    let c:int64 = self.state[2]
    let d:int64 = self.state[3]
    
    || Round1
    set a = {step-p a, {round1-p b, c, d}, b, c, d, {to-int-p self.input-buf,  0} + 0x0d76aa478, 7}
    set d = {step-p d, {round1-p a, b, c}, a, b, c, {to-int-p self.input-buf,  1} + 0x0e8c7b756, 12}
    set c = {step-p c, {round1-p d, a, b}, d, a, b, {to-int-p self.input-buf,  2} + 0x0242070db, 17}
    set b = {step-p b, {round1-p c, d, a}, c, d, a, {to-int-p self.input-buf,  3} + 0x0c1bdceee, 22}
    set a = {step-p a, {round1-p b, c, d}, b, c, d, {to-int-p self.input-buf,  4} + 0x0f57c0faf, 7}
    set d = {step-p d, {round1-p a, b, c}, a, b, c, {to-int-p self.input-buf,  5} + 0x04787c62a, 12}
    set c = {step-p c, {round1-p d, a, b}, d, a, b, {to-int-p self.input-buf,  6} + 0x0a8304613, 17}
    set b = {step-p b, {round1-p c, d, a}, c, d, a, {to-int-p self.input-buf,  7} + 0x0fd469501, 22}
    set a = {step-p a, {round1-p b, c, d}, b, c, d, {to-int-p self.input-buf,  8} + 0x0698098d8, 7}
    set d = {step-p d, {round1-p a, b, c}, a, b, c, {to-int-p self.input-buf,  9} + 0x08b44f7af, 12}
    set c = {step-p c, {round1-p d, a, b}, d, a, b, {to-int-p self.input-buf, 10} + 0x0ffff5bb1, 17}
    set b = {step-p b, {round1-p c, d, a}, c, d, a, {to-int-p self.input-buf, 11} + 0x0895cd7be, 22}
    set a = {step-p a, {round1-p b, c, d}, b, c, d, {to-int-p self.input-buf, 12} + 0x06b901122, 7}
    set d = {step-p d, {round1-p a, b, c}, a, b, c, {to-int-p self.input-buf, 13} + 0x0fd987193, 12}
    set c = {step-p c, {round1-p d, a, b}, d, a, b, {to-int-p self.input-buf, 14} + 0x0a679438e, 17}
    set b = {step-p b, {round1-p c, d, a}, c, d, a, {to-int-p self.input-buf, 15} + 0x049b40821, 22}
    
    || Round2
    set a = {step-p a, {round2-p b, c, d}, b, c, d, {to-int-p self.input-buf,  1} + 0x0f61e2562, 5}
    set d = {step-p d, {round2-p a, b, c}, a, b, c, {to-int-p self.input-buf,  6} + 0x0c040b340, 9}
    set c = {step-p c, {round2-p d, a, b}, d, a, b, {to-int-p self.input-buf, 11} + 0x0265e5a51, 14}
    set b = {step-p b, {round2-p c, d, a}, c, d, a, {to-int-p self.input-buf,  0} + 0x0e9b6c7aa, 20}
    set a = {step-p a, {round2-p b, c, d}, b, c, d, {to-int-p self.input-buf,  5} + 0x0d62f105d, 5}
    set d = {step-p d, {round2-p a, b, c}, a, b, c, {to-int-p self.input-buf, 10} + 0x002441453, 9}
    set c = {step-p c, {round2-p d, a, b}, d, a, b, {to-int-p self.input-buf, 15} + 0x0d8a1e681, 14}
    set b = {step-p b, {round2-p c, d, a}, c, d, a, {to-int-p self.input-buf,  4} + 0x0e7d3fbc8, 20}
    set a = {step-p a, {round2-p b, c, d}, b, c, d, {to-int-p self.input-buf,  9} + 0x021e1cde6, 5}
    set d = {step-p d, {round2-p a, b, c}, a, b, c, {to-int-p self.input-buf, 14} + 0x0c33707d6, 9}
    set c = {step-p c, {round2-p d, a, b}, d, a, b, {to-int-p self.input-buf,  3} + 0x0f4d50d87, 14}
    set b = {step-p b, {round2-p c, d, a}, c, d, a, {to-int-p self.input-buf,  8} + 0x0455a14ed, 20}
    set a = {step-p a, {round2-p b, c, d}, b, c, d, {to-int-p self.input-buf, 13} + 0x0a9e3e905, 5}
    set d = {step-p d, {round2-p a, b, c}, a, b, c, {to-int-p self.input-buf,  2} + 0x0fcefa3f8, 9}
    set c = {step-p c, {round2-p d, a, b}, d, a, b, {to-int-p self.input-buf,  7} + 0x0676f02d9, 14}
    set b = {step-p b, {round2-p c, d, a}, c, d, a, {to-int-p self.input-buf, 12} + 0x08d2a4c8a, 20}
    
    || Round3
    set a = {step-p a, {round3-p b, c, d}, b, c, d, {to-int-p self.input-buf,  5} + 0x0fffa3942, 4}
    set d = {step-p d, {round3-p a, b, c}, a, b, c, {to-int-p self.input-buf,  8} + 0x08771f681, 11}
    set c = {step-p c, {round3-p d, a, b}, d, a, b, {to-int-p self.input-buf, 11} + 0x06d9d6122, 16}
    set b = {step-p b, {round3-p c, d, a}, c, d, a, {to-int-p self.input-buf, 14} + 0x0fde5380c, 23}
    set a = {step-p a, {round3-p b, c, d}, b, c, d, {to-int-p self.input-buf,  1} + 0x0a4beea44, 4}
    set d = {step-p d, {round3-p a, b, c}, a, b, c, {to-int-p self.input-buf,  4} + 0x04bdecfa9, 11}
    set c = {step-p c, {round3-p d, a, b}, d, a, b, {to-int-p self.input-buf,  7} + 0x0f6bb4b60, 16}
    set b = {step-p b, {round3-p c, d, a}, c, d, a, {to-int-p self.input-buf, 10} + 0x0bebfbc70, 23}
    set a = {step-p a, {round3-p b, c, d}, b, c, d, {to-int-p self.input-buf, 13} + 0x0289b7ec6, 4}
    set d = {step-p d, {round3-p a, b, c}, a, b, c, {to-int-p self.input-buf,  0} + 0x0eaa127fa, 11}
    set c = {step-p c, {round3-p d, a, b}, d, a, b, {to-int-p self.input-buf,  3} + 0x0d4ef3085, 16}
    set b = {step-p b, {round3-p c, d, a}, c, d, a, {to-int-p self.input-buf,  6} + 0x004881d05, 23}
    set a = {step-p a, {round3-p b, c, d}, b, c, d, {to-int-p self.input-buf,  9} + 0x0d9d4d039, 4}
    set d = {step-p d, {round3-p a, b, c}, a, b, c, {to-int-p self.input-buf, 12} + 0x0e6db99e5, 11}
    set c = {step-p c, {round3-p d, a, b}, d, a, b, {to-int-p self.input-buf, 15} + 0x01fa27cf8, 16}
    set b = {step-p b, {round3-p c, d, a}, c, d, a, {to-int-p self.input-buf,  2} + 0x0c4ac5665, 23}
    
    || Round4
    set a = {step-p a, {round4-p b, c, d}, b, c, d, {to-int-p self.input-buf,  0} + 0x0f4292244, 6}
    set d = {step-p d, {round4-p a, b, c}, a, b, c, {to-int-p self.input-buf,  7} + 0x0432aff97, 10}
    set c = {step-p c, {round4-p d, a, b}, d, a, b, {to-int-p self.input-buf, 14} + 0x0ab9423a7, 15}
    set b = {step-p b, {round4-p c, d, a}, c, d, a, {to-int-p self.input-buf,  5} + 0x0fc93a039, 21}
    set a = {step-p a, {round4-p b, c, d}, b, c, d, {to-int-p self.input-buf, 12} + 0x0655b59c3, 6}
    set d = {step-p d, {round4-p a, b, c}, a, b, c, {to-int-p self.input-buf,  3} + 0x08f0ccc92, 10}
    set c = {step-p c, {round4-p d, a, b}, d, a, b, {to-int-p self.input-buf, 10} + 0x0ffeff47d, 15}
    set b = {step-p b, {round4-p c, d, a}, c, d, a, {to-int-p self.input-buf,  1} + 0x085845dd1, 21}
    set a = {step-p a, {round4-p b, c, d}, b, c, d, {to-int-p self.input-buf,  8} + 0x06fa87e4f, 6}
    set d = {step-p d, {round4-p a, b, c}, a, b, c, {to-int-p self.input-buf, 15} + 0x0fe2ce6e0, 10}
    set c = {step-p c, {round4-p d, a, b}, d, a, b, {to-int-p self.input-buf,  6} + 0x0a3014314, 15}
    set b = {step-p b, {round4-p c, d, a}, c, d, a, {to-int-p self.input-buf, 13} + 0x04e0811a1, 21}
    set a = {step-p a, {round4-p b, c, d}, b, c, d, {to-int-p self.input-buf,  4} + 0x0f7537e82, 6}
    set d = {step-p d, {round4-p a, b, c}, a, b, c, {to-int-p self.input-buf, 11} + 0x0bd3af235, 10}
    set c = {step-p c, {round4-p d, a, b}, d, a, b, {to-int-p self.input-buf,  2} + 0x02ad7d2bb, 15}
    set b = {step-p b, {round4-p c, d, a}, c, d, a, {to-int-p self.input-buf,  9} + 0x0eb86d391, 21}
    
    set self.state[0] = self.state[0] + a
    set self.state[1] = self.state[1] + b
    set self.state[2] = self.state[2] + c
    set self.state[3] = self.state[3] + d
  }
}

